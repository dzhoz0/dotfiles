{
  "cpcf": {
    "prefix": "cpcf",
    "body": [
      "/*",
      "    it could have been better :)",
      "    it will next time ;)",
      "*/",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#define int long long",
      "#define INF 1e18",
      "#define f first",
      "#define s second",
      "#define pii pair<int, int>",
      "#define vi vector<int>",
      "",
      "const int MOD = 1'000'000'000 + 7;",
      "",
      "void setIO(string name = \"\")",
      "{",
      "    ios_base::sync_with_stdio(0);",
      "    cin.tie(0), cout.tie(0);",
      "#ifdef LOCAL",
      "    freopen(\"inp.txt\", \"r\", stdin);",
      "    freopen(\"out.txt\", \"w\", stdout);",
      "#else",
      "    if (!name.empty())",
      "    {",
      "        freopen((name + \".INP\").c_str(), \"r\", stdin);",
      "        freopen((name + \".OUT\").c_str(), \"w\", stdout);",
      "    }",
      "#endif",
      "}",
      "",
      "void solve()",
      "{",
      "    ",
      "}",
      "signed main()",
      "{",
      "    setIO();",
      "    int t = 1;",
      "    // cin >> t;",
      "    while (t--)",
      "        solve();",
      "}",
      ""
    ],
    "description": "Generated from cpcf.cpp",
    "scope": "cpp"
  },
  "cpdebug": {
    "prefix": "cpdebug",
    "body": [
      "// START OF DEBUG",
      "#define db(val) \"[\"#val\" = \"<<(val)<<\"] \"",
      "#define print_op(...) ostream& operator<<(ostream& out, const __VA_ARGS__& u)",
      "// for printing std::pair",
      "template<class U, class V> print_op(pair<U, V>) {",
      "    return out << \"(\" << u.first << \", \" << u.second << \")\";",
      "}",
      "// for printing collection",
      "template<class Con, class = decltype(begin(declval<Con>()))>",
      "typename enable_if<!is_same<Con, string>::value, ostream&>::type",
      "operator<<(ostream& out, const Con& con) { ",
      "    out << \"{\";",
      "    for (auto beg = con.begin(), it = beg; it != con.end(); ++it)",
      "        out << (it == beg ? \"\" : \", \") << *it;",
      "    return out << \"}\";",
      "}",
      "// for printing std::tuple",
      "template<size_t i, class T> ostream& print_tuple_utils(ostream& out, const T& tup) {",
      "    if constexpr(i == tuple_size<T>::value) return out << \")\"; ",
      "    else return print_tuple_utils<i + 1, T>(out << (i ? \", \" : \"(\") << get<i>(tup), tup); ",
      "}",
      "template<class ...U> print_op(tuple<U...>) {",
      "    return print_tuple_utils<0, tuple<U...>>(out, u);",
      "}",
      "// END OF DEBUG"
    ],
    "description": "Generated from cpdebug.cpp",
    "scope": "cpp"
  },
  "ds_dsu": {
    "prefix": "ds_dsu",
    "body": [
      "struct DSU {",
      "    int n;",
      "    vi par;",
      "    vi sz;",
      "    int cmps = 0;",
      "    void make_set(int v) {",
      "        par[v] = v;",
      "        sz[v] = 1;",
      "        cmps++;",
      "    }",
      "",
      "    int find_set(int v) {",
      "        if(v == par[v]) return v;",
      "        return par[v] = find_set(par[v]);",
      "    }",
      "",
      "    void union_set(int u, int v) {",
      "        u = find_set(u);",
      "        v = find_set(v);",
      "        if(u != v) {",
      "            cmps--;",
      "            if(sz[u] < sz[v]) swap(u, v);",
      "            par[v] = u;",
      "            sz[u] += sz[v];",
      "        }",
      "    }",
      "",
      "    void init() {",
      "        for(int i = 1; i <= n; i++) make_set(i);",
      "    }",
      "",
      "    DSU(int _n, bool is_init = false) {",
      "        n = _n;",
      "        par.resize(n + 1);",
      "        sz.resize(n + 1);",
      "        if(is_init) init();",
      "    }    ",
      "};"
    ],
    "description": "Generated from ds/dsu.cpp",
    "scope": "cpp"
  },
  "ds_fenwick": {
    "prefix": "ds_fenwick",
    "body": [
      "struct FenwickTree {",
      "    int n;",
      "    vi bit;",
      "    FenwickTree(int sz) {",
      "        n = sz;",
      "        bit.resize(n + 1);",
      "    }",
      "    void upd(int id, int v) {",
      "        while(id <= n) {",
      "            bit[id] += v;",
      "            id += id & (-id);",
      "        }",
      "    }",
      "    int query(int id) {",
      "        int res = 0;",
      "        while(id > 0) {",
      "            res += bit[id];",
      "            id -= id & (-id);",
      "        }",
      "        return res;",
      "    }",
      " ",
      "    int queryRange(int l, int r) {",
      "        return query(r) - query(l - 1);",
      "    }",
      "};"
    ],
    "description": "Generated from ds/fenwick.cpp",
    "scope": "cpp"
  },
  "ds_linecontainer": {
    "prefix": "ds_linecontainer",
    "body": [
      "struct Line {",
      "\tmutable int k, m, p;",
      "\tbool operator<(const Line& o) const { return k < o.k; }",
      "\tbool operator<(int x) const { return p < x; }",
      "};",
      "",
      "struct LineContainer : multiset<Line, less<>> {",
      "\tbool is_max; ",
      "\tLineContainer(bool fl = true) : is_max(fl) {}",
      "    // LineContainer cht(true): query max",
      "    // LineContainer cht(false): query min",
      "",
      "\tint div(int a, int b) { ",
      "\t\treturn a / b - ((a ^ b) < 0 && a % b);",
      "\t}",
      "",
      "\tbool isect(iterator x, iterator y) {",
      "\t\tif (y == end()) return x->p = INF, 0;",
      "\t\tif (x->k == y->k) ",
      "\t\t\tx->p = (x->m > y->m ? INF : -INF);",
      "\t\telse ",
      "\t\t\tx->p = div(y->m - x->m, x->k - y->k);",
      "\t\treturn x->p >= y->p;",
      "\t}",
      "",
      "\tvoid add(int k, int m) {",
      "\t\tif (!is_max) k = -k, m = -m;",
      "",
      "\t\tauto z = insert({k, m, 0}), y = z++, x = y;",
      "\t\twhile (isect(y, z)) z = erase(z);",
      "\t\tif (x != begin() && isect(--x, y)) isect(x, y = erase(y));",
      "\t\twhile ((y = x) != begin() && (--x)->p >= y->p)",
      "\t\t\tisect(x, erase(y));",
      "\t}",
      "",
      "\tint query(int x) const {",
      "\t\tassert(!empty());",
      "\t\tauto l = *lower_bound(x);",
      "\t\tint res = l.k * x + l.m;",
      "\t\treturn is_max ? res : -res;",
      "\t}",
      "};"
    ],
    "description": "Generated from ds/linecontainer.cpp",
    "scope": "cpp"
  },
  "ds_nsegtree": {
    "prefix": "ds_nsegtree",
    "body": [
      "struct SegmentTree {",
      "    int n;",
      "    vector<int> a;",
      "    vector<int> st;",
      "",
      "    SegmentTree(int _n) {",
      "        n = _n;",
      "        a.assign(n + 1, 0);",
      "        st.assign(4 * n + 5, INF);",
      "    }",
      "",
      "    void build(int id, int l, int r) {",
      "        if (l == r) {",
      "            st[id] = a[l];",
      "            return;",
      "        }",
      "        int mid = (l + r) >> 1;",
      "        build(id * 2, l, mid);",
      "        build(id * 2 + 1, mid + 1, r);",
      "        st[id] = min(st[id * 2], st[id * 2 + 1]);",
      "    }",
      "",
      "    void update(int id, int l, int r, int i, int val) {",
      "        if (i < l || i > r) return;",
      "        if (l == r) {",
      "            st[id] = val;",
      "            return;",
      "        }",
      "        int mid = (l + r) >> 1;",
      "        update(id * 2, l, mid, i, val);",
      "        update(id * 2 + 1, mid + 1, r, i, val);",
      "        st[id] = min(st[id * 2], st[id * 2 + 1]);",
      "    }",
      "",
      "    int get(int id, int l, int r, int u, int v) {",
      "        if (v < l || u > r) return INF;",
      "        if (u <= l && r <= v) return st[id];",
      "        int mid = (l + r) >> 1;",
      "        int left = get(id * 2, l, mid, u, v);",
      "        int right = get(id * 2 + 1, mid + 1, r, u, v);",
      "        return min(left, right);",
      "    }",
      "};"
    ],
    "description": "Generated from ds/nsegtree.cpp",
    "scope": "cpp"
  },
  "ds_psegtree": {
    "prefix": "ds_psegtree",
    "body": [
      "struct PersistentSegTree {",
      "    struct Node {",
      "        int val = 0;",
      "        int l = -1, r = -1;",
      "",
      "        Node() {}",
      "        Node(int v) : val(v) {}",
      "        Node(int v, int L, int R) : val(v), l(L), r(R) {}",
      "",
      "        Node operator+(const Node &a, const Node &b) {",
      "            return Node(a.val + b.val, a.l, b.r);",
      "        }",
      "    };",
      "",
      "    vector<Node> st;",
      "    int n, id;",
      "",
      "    void init(int _n){",
      "        n = _n; ",
      "        st.resize(20 * _n + 5);",
      "    }",
      "",
      "    int add_copy(int root) {",
      "        st.push_back(st[root]);",
      "        return id++;",
      "    }",
      "",
      "    int build(int l, int r) {",
      "        int my = id++;",
      "        st.emplace_back();",
      "        if (l == r) return my;",
      "",
      "        int mid = (l + r) >> 1;",
      "        int left = build(l, mid);",
      "        int right = build(mid + 1, r);",
      "        st[my] = st[left] + st[right];",
      "        st[my].l = left;",
      "        st[my].r = right;",
      "        return my;",
      "    }",
      "",
      "    int update(int cur, int l, int r, int k, int x) {",
      "        if (k < l || k > r) return cur;",
      "        if (l == r) {",
      "            st.emplace_back(x);",
      "            return id++;",
      "        }",
      "",
      "        int mid = (l + r) >> 1;",
      "        int newLeft = update(st[cur].l, l, mid, k, x);",
      "        int newRight = updateRec(st[cur].r, mid + 1, r, k, x);",
      "        st.emplace_back(st[newLeft] + st[newRight]);",
      "        st.back().l = newLeft;",
      "        st.back().r = newRight;",
      "        return id++;",
      "    }",
      "",
      "    int queryRec(int cur, int l, int r, int L, int R) {",
      "        if (R < l || r < L) return 0;",
      "        if (L <= l && r <= R) return st[cur].val;",
      "        int mid = (l + r) >> 1;",
      "        return queryRec(st[cur].l, l, mid, L, R) +",
      "               queryRec(st[cur].r, mid + 1, r, L, R);",
      "    }",
      "};"
    ],
    "description": "Generated from ds/psegtree.cpp",
    "scope": "cpp"
  },
  "math_binpow": {
    "prefix": "math_binpow",
    "body": [
      "int binmul(int a, int b, int mod = MOD) {",
      "    int res = 0;",
      "    a %= mod;",
      "    while (b > 0) {",
      "        if (b & 1) res = (res + a) % mod;",
      "        a = (a + a) % mod;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "int binpow(int a, int b, int mod = MOD) {",
      "    int res = 1;",
      "    a %= mod;",
      "    while (b > 0) {",
      "        if (b & 1) res = binmul(res, a, mod);",
      "        a = binmul(a, a, mod);",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "Generated from math/binpow.cpp",
    "scope": "cpp"
  },
  "math_matrix": {
    "prefix": "math_matrix",
    "body": [
      "struct Matrix {",
      "    int n, m;",
      "    vector<vi> d;",
      "    void init(vector<vi> v) {",
      "        d = v;",
      "        n = v.size();",
      "        m = v[0].size();",
      "    }",
      " ",
      "    void I(int n) {",
      "        vector<vi> v(n, vi(n, 0));",
      "        for(int i = 0; i < n; i++) v[i][i] = 1; ",
      "        init(v);",
      "    }",
      " ",
      "    Matrix operator*(Matrix &other) {",
      "        Matrix res;",
      "        res.n = n;",
      "        res.m = other.m;",
      "        res.d.resize(n, vi(m, 0));",
      "        for(int i = 0; i < res.n; i++) {",
      "            for(int j = 0; j < res.m; j++) {",
      "                for(int k = 0; k < other.n; k++) {",
      "                    res.d[i][j] += d[i][k] * other.d[k][j];",
      "                    res.d[i][j] %= MOD;",
      "                }",
      "            }",
      "        }",
      "        return res;",
      "    }",
      " ",
      "    Matrix operator^(int k) {",
      "        assert(n == m);",
      "        Matrix res; res.I(n);",
      "        Matrix cur; cur.init(d);",
      "        while(k > 0) {",
      "            if(k & 1) res = res * cur;",
      "            cur = cur * cur;",
      "            k >>= 1; ",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "Generated from math/matrix.cpp",
    "scope": "cpp"
  },
  "misc_compressor": {
    "prefix": "misc_compressor",
    "body": [
      "template <typename T> struct Compressor {",
      "    vector<T> v;",
      "",
      "    int sz() { return (int)v.size(); }",
      "",
      "    void add(T x) {",
      "        v.push_back(x);",
      "    }",
      "    ",
      "    void init() {",
      "        sort(v.begin(), v.end());",
      "        v.erase(unique(v.begin(), v.end()), v.end());",
      "    }",
      "",
      "    int id(T key) {",
      "        return lower_bound(v.begin(), v.end(), key) - v.begin() + 1;",
      "    }",
      "};"
    ],
    "description": "Generated from misc/compressor.cpp",
    "scope": "cpp"
  },
  "str_hash": {
    "prefix": "str_hash",
    "body": [
      "struct Hash {",
      "    Hash() {}",
      "    const int BASE = 53;",
      "    vi pr = {1'000'000'000 + 7, 998244353, 4518541637, 7385466377};",
      "    int mod;",
      "    int n;",
      "    vi hash, pw;",
      "    Hash(int p, string s) {",
      "        n = s.size();",
      " ",
      "        mod = pr[p];",
      "        s = \"@\" + s;",
      " ",
      "        pw.resize(n + 1);",
      "        hash.resize(n + 1);",
      "        pw[0] = 1;",
      "        for(int i = 1; i <= n; i++) pw[i] = (pw[i - 1] * BASE) % mod;",
      "        for(int i = 1; i <= n; i++) hash[i] = ((hash[i - 1] * BASE) + (s[i] - 'a' + 1)) % mod;",
      "    }",
      " ",
      "    int get(int l, int r) {",
      "        return (hash[r] - hash[l - 1] * pw[r - l + 1] + mod * mod) % mod;",
      "    }",
      "};"
    ],
    "description": "Generated from str/hash.cpp",
    "scope": "cpp"
  },
  "str_suffixarray": {
    "prefix": "str_suffixarray",
    "body": [
      "struct SuffixArray {",
      "    vi sort_shifts(string s, bool cyclic, vector<vi> &ck) {",
      "        if (!cyclic) s.push_back('$');",
      "        int n = (int)s.size();",
      "        const int ALPH = 256;",
      " ",
      "        vi p(n), c(n), cnt(max(ALPH, n), 0);",
      "        for (unsigned char ch : s) cnt[ch]++;",
      "        for (int i = 1; i < (int)cnt.size(); i++) cnt[i] += cnt[i-1];",
      "        for (int i = n-1; i >= 0; --i) p[--cnt[(unsigned char)s[i]]] = i;",
      " ",
      "        c[p[0]] = 0; int classes = 1;",
      "        for (int i = 1; i < n; ++i) {",
      "            if (s[p[i]] != s[p[i-1]]) classes++;",
      "            c[p[i]] = classes - 1;",
      "        }",
      " ",
      "        ck.clear();",
      "        ck.push_back(c);",
      " ",
      "        vi pn(n), cn(n);",
      "        for (int h = 0; (1 << h) < n; h++) {",
      "            int shift = 1 << h;",
      "            for (int i = 0; i < n; i++) {",
      "                pn[i] = p[i] - shift;",
      "                if (pn[i] < 0) pn[i] += n;",
      "            }",
      "            fill(cnt.begin(), cnt.begin() + classes, 0);",
      "            for (int i = 0; i < n; i++) ++cnt[c[pn[i]]];",
      "            for (int i = 1; i < classes; i++) cnt[i] += cnt[i-1];",
      "            for (int i = n-1; i >= 0; i--) p[--cnt[c[pn[i]]]] = pn[i];",
      " ",
      "            cn[p[0]] = 0; classes = 1;",
      "            for (int i = 1; i < n; i++) {",
      "                pii cur = {c[p[i]], c[(p[i] + shift) % n]};",
      "                pii prev = {c[p[i-1]], c[(p[i-1] + shift) % n]};",
      "                if (cur != prev) ++classes;",
      "                cn[p[i]] = classes - 1;",
      "            }",
      "            ck.push_back(cn);",
      "            c.swap(cn);",
      "        }",
      " ",
      "        if (!cyclic) p.erase(p.begin());",
      "        return p;",
      "    }",
      " ",
      "    int lcp(int i, int j, vector<vi> &ck) {",
      "        int ans = 0;",
      "        if (ck.empty()) return 0;",
      "        int n = ck[0].size();",
      "        int maxk = (int)ck.size() - 1;",
      "        for (int k = maxk; k >= 0; --k) {",
      "            if (ck[k][i % n] == ck[k][j % n]) {",
      "                ans += (1 << k);",
      "                i += (1 << k);",
      "                j += (1 << k);",
      "            }",
      "        }",
      "        return ans;",
      "    }",
      " ",
      "    vi build_suffix_array(string s) { vector<vi> ck; return sort_shifts(s, false, ck); }",
      "    vi build_cyclic_shifts(string s) { vector<vi> ck; return sort_shifts(s, true, ck); }",
      "};"
    ],
    "description": "Generated from str/suffixarray.cpp",
    "scope": "cpp"
  },
  "trees_hld": {
    "prefix": "trees_hld",
    "body": [
      "struct HLD {",
      "    int n;",
      "    vector<vi> g;",
      "    vi p, depth, sz, in, out, nxt, heavy;",
      "    int timer = 0;",
      "",
      "    HLD() {}",
      "    HLD(int _n) { init(_n); }",
      "",
      "    void init(int _n) {",
      "        n = _n;",
      "        g.assign(n+1, {});",
      "        p.assign(n+1, 0);",
      "        depth.assign(n+1, 0);",
      "        sz.assign(n+1, 0);",
      "        in.assign(n+1, 0);",
      "        out.assign(n+1, 0);",
      "        nxt.assign(n+1, 0);",
      "        heavy.assign(n+1, -1);",
      "        timer = 0;",
      "    }",
      "",
      "    void add_edge(int u, int v) {",
      "        g[u].push_back(v);",
      "        g[v].push_back(u);",
      "    }",
      "",
      "    void dfs_sz(int u, int par) {",
      "        p[u] = par;",
      "        sz[u] = 1;",
      "        heavy[u] = -1;",
      "        for (int &v : g[u]) {",
      "            if (v == par) continue;",
      "            depth[v] = depth[u] + 1;",
      "            dfs_sz(v, u);",
      "            sz[u] += sz[v];",
      "            if (heavy[u] == -1 || sz[v] > sz[heavy[u]]) heavy[u] = v;",
      "            if (g[u][0] == par || sz[v] > sz[g[u][0]]) swap(v, g[u][0]);",
      "        }",
      "    }",
      "",
      "    void dfs_hld(int u, int par, int head) {",
      "        in[u] = ++timer;",
      "        nxt[u] = head;",
      "        for (int v : g[u]) {",
      "            if (v == par) continue;",
      "            if (v == g[u][0]) {",
      "                dfs_hld(v, u, head);",
      "            } else {",
      "                dfs_hld(v, u, v);",
      "            }",
      "        }",
      "        out[u] = timer;",
      "    }",
      "",
      "    void build(int root = 1) {",
      "        timer = 0;",
      "        depth[root] = 0;",
      "        dfs_sz(root, 0);",
      "        dfs_hld(root, 0, root);",
      "    }",
      "",
      "    // Insert data structures functions here",
      "    void range_upd(int L, int R, int val) {",
      "    }",
      "",
      "    int range_query(int L, int R) {",
      "        return 0;",
      "    }",
      "",
      "    // subtree add: add val to all nodes in subtree u",
      "    void subtree_add(int u, int val) {",
      "        range_upd(in[u], out[u], val); ",
      "    }",
      "",
      "    int point_query(int u) {",
      "        return range_query(in[u], in[u]); ",
      "    }",
      "",
      "    void path_add(int a, int b, int val) {",
      "        while (nxt[a] != nxt[b]) {",
      "            if (depth[nxt[a]] < depth[nxt[b]]) swap(a, b);",
      "            int head = nxt[a];",
      "            range_upd(in[head], in[a], val);",
      "            a = p[head];",
      "        }",
      "        if (depth[a] > depth[b]) swap(a, b);",
      "        range_upd(in[a], in[b], val);",
      "    }",
      "",
      "    int path_query(int a, int b) {",
      "        int res = 0;",
      "        while (nxt[a] != nxt[b]) {",
      "            if (depth[nxt[a]] < depth[nxt[b]]) swap(a, b);",
      "            int head = nxt[a];",
      "            res += range_query(in[head], in[a]);",
      "            a = p[head];",
      "        }",
      "        if (depth[a] > depth[b]) swap(a, b);",
      "        res += range_query(in[a], in[b]);",
      "        return res;",
      "    }",
      "};",
      "",
      ""
    ],
    "description": "Generated from trees/hld.cpp",
    "scope": "cpp"
  }
}

