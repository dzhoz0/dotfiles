{
    "CP Template": {
      "prefix": "cpcf",
      "body": [  
        "#include <bits/stdc++.h>",
        "using namespace std;",
        "",
        "#define int long long",
        "#define INF 1e18",
        "#define f first",
        "#define s second",
        "#define pii pair<int, int>",
        "#define vi vector<int>",
        "",
        "const int MOD = 1'000'000'000 + 7;",
        "",
        "void setIO(string name = \"\")",
        "{",
        "    ios_base::sync_with_stdio(0);",
        "    cin.tie(0), cout.tie(0);",
        "#ifdef LOCAL",
        "    freopen(\"inp.txt\", \"r\", stdin);",
        "    freopen(\"out.txt\", \"w\", stdout);",
        "#else",
        "    if (!name.empty())",
        "    {",
        "        freopen((name + \".INP\").c_str(), \"r\", stdin);",
        "        freopen((name + \".OUT\").c_str(), \"w\", stdout);",
        "    }",
        "#endif",
        "}",
        "",
        "void solve()",
        "{",
        "    $0",
        "}",
        "signed main()",
        "{",
        "    setIO();",
        "    int t = 1;",
        "    // cin >> t;",
        "    while (t--)",
        "        solve();",
        "}",
        ""
      ],
      "description": "CP Template"
    },
    "Debug template": {
      "prefix": "cpdebug",
      "body": [
        "// START OF DEBUG",
        "#define db(val) \"[\"#val\" = \"<<(val)<<\"] \"",
        "#define print_op(...) ostream& operator<<(ostream& out, const __VA_ARGS__& u)",
        "// for printing std::pair",
        "template<class U, class V> print_op(pair<U, V>) {",
        "    return out << \"(\" << u.first << \", \" << u.second << \")\";",
        "}",
        "// for printing collection",
        "template<class Con, class = decltype(begin(declval<Con>()))>",
        "typename enable_if<!is_same<Con, string>::value, ostream&>::type",
        "operator<<(ostream& out, const Con& con) { ",
        "    out << \"{\";",
        "    for (auto beg = con.begin(), it = beg; it != con.end(); ++it)",
        "        out << (it == beg ? \"\" : \", \") << *it;",
        "    return out << \"}\";",
        "}",
        "// for printing std::tuple",
        "template<size_t i, class T> ostream& print_tuple_utils(ostream& out, const T& tup) {",
        "    if constexpr(i == tuple_size<T>::value) return out << \")\"; ",
        "    else return print_tuple_utils<i + 1, T>(out << (i ? \", \" : \"(\") << get<i>(tup), tup); ",
        "}",
        "template<class ...U> print_op(tuple<U...>) {",
        "    return print_tuple_utils<0, tuple<U...>>(out, u);",
        "}",
        "// END OF DEBUG"
      ],
      "description": ":)"
    },
    "Quick segtree": {
      "prefix": "ds_nsegtree",
      "body": [
        "struct SegmentTree {",
        "    vi t;",
        "    int f(int a, int b) {",
        "        return a + b;",
        "    }",
        "    SegmentTree(vi &a) {",
        "        int n = (int)a.size();",
        "        t.resize(4 * n);",
        "        build(a, 1, 0, n - 1);",
        "    }",
        "    // Default paramenters, v = 1, tl = 0, tr = 1",
        "    void build(vi &a, int v, int tl, int tr) {",
        "        if(tl == tr) t[v] = a[tl];",
        "        else {",
        "            int tm = (tl + tr) / 2;",
        "            build(a, v * 2, tl, tm);",
        "            build(a, v * 2 + 1, tm + 1, tr);",
        "            t[v] = f(t[v * 2], t[v * 2 + 1]);",
        "        }",
        "    }",
        "    ",
        "    void upd(int v, int tl, int tr, int pos, int new_val) {",
        "        if(tl == tr) t[v] = new_val;",
        "        else {",
        "            int tm = (tl + tr) / 2;",
        "            if(pos <= tm) upd(v * 2, tl, tm, pos, new_val);",
        "            else upd(v * 2+1, tm+1,tr,pos, new_val);",
        "            t[v] = f(t[v*2],t[v*2+1]);",
        "        }",
        "    }",
        "",
        "    int query(int v, int tl, int tr, int l, int r) {",
        "        if(l > r) return 0;",
        "        if(l == tl && r == tr) return t[v];",
        "        int tm = (tl + tr) / 2;",
        "        int val1 = query(v * 2, tl, tm, l, min(r, tm));",
        "        int val2 = query(v * 2+1, tm+1,tr, max(l, tm + 1), r);",
        "        return f(val1, val2);",
        "    }",
        "};",
        ""
      ],
      "description": "Quick segtree"
    },
    "Compressor": {
      "prefix": "misc_compress",
      "body": [
        "struct Compressor {",
        "    vi v;",
        "    int sz() { return (int)v.size(); }",
        "",
        "    void add(int x) {",
        "        v.push_back(x);",
        "    }",
        "    ",
        "    void init() {",
        "        sort(v.begin(), v.end());",
        "        v.erase(unique(v.begin(), v.end()), v.end());",
        "    }",
        "",
        "    int id(int key) {",
        "        return lower_bound(v.begin(), v.end(), key) - v.begin() + 1;",
        "    }",
        "};",
        ""
      ],
      "description": "Compressor"
    },
    "Suffix array O(nlogn)": {
      "prefix": "str_suffixarray",
      "body": [
        "void count_sort(vi &p, vi &c) {",
        "    int n = p.size();",
        "    vi cnt(n, 0); for(int x : c) cnt[x]++; for(int i = 1; i < n; i++) cnt[i] += cnt[i - 1];",
        "    vi p_new(n);",
        "    for(int i = n - 1; i >= 0; i--) p_new[--cnt[c[p[i]]]] = p[i];",
        "    p.swap(p_new);",
        "}",
        "",
        "vi suffix_array(string s) {",
        "    int n = s.size();",
        "    vi p(n), c(n, 0);   ",
        "",
        "    {",
        "        // k = 0;",
        "        vi cnt(26, 0); for(int i = 0; i < n; i++) cnt[s[i] - 'a']++;",
        "        for(int i = 1; i < 26; i++) cnt[i] += cnt[i - 1];",
        "        for(int i = n - 1; i >= 0; i--) p[--cnt[s[i] - 'a']] = i;",
        "        for(int i = 1; i < n; i++) c[p[i]] = c[p[i - 1]] + (s[p[i]] != s[p[i - 1]]);",
        "    }",
        "    ",
        "    for(int k = 0; (1 << k) < n; k++) {",
        "        for(int &i : p) i = (i - (1 << k) + n) % n;",
        "        count_sort(p, c);",
        "        vi c_new(n, 0);",
        "        for(int i = 1; i < n; i++) {",
        "            pii cur = {c[p[i]], c[(p[i] + (1 << k)) % n]};",
        "            pii prv = {c[p[i - 1]], c[(p[i - 1] + (1 << k)) % n]}; ",
        "            c_new[p[i]] = c_new[p[i - 1]] + (cur != prv);",
        "        }",
        "        c.swap(c_new);",
        "    }",
        "",
        "    return p;",
        "}"
      ],
      "description": "Suffix array O(nlogn)"
    },
    "String poly hashing": {
      "prefix": "str_hash",
      "body": [
        "struct Hash {",
        "    Hash() {}",
        "    const int BASE = 53;",
        "    vi pr = {1'000'000'000 + 7, 998244353, 4518541637, 7385466377};",
        "    int mod;",
        "    int n;",
        "    vi hash, pw;",
        "    Hash(int p, string s) {",
        "        n = s.size();",
        " ",
        "        mod = pr[p];",
        "        s = \"@\" + s;",
        " ",
        "        pw.resize(n + 1);",
        "        hash.resize(n + 1);",
        "        pw[0] = 1;",
        "        for(int i = 1; i <= n; i++) pw[i] = (pw[i - 1] * BASE) % mod;",
        "        for(int i = 1; i <= n; i++) hash[i] = ((hash[i - 1] * BASE) + (s[i] - 'a' + 1)) % mod;",
        "    }",
        " ",
        "    int get(int l, int r) {",
        "        return (hash[r] - hash[l - 1] * pw[r - l + 1] + mod * mod) % mod;",
        "    }",
        "};"
      ],
      "description": "string poly hashing"
    }, 
    "DSU": {
      "prefix": "ds_dsu",
      "body": [
        "struct DSU {",
        "    int n;",
        "    vi par;",
        "    vi sz;",
        "",
        "    void make_set(int v) {",
        "        par[v] = v;",
        "        sz[v] = 1;",
        "    }",
        "",
        "    int find_set(int v) {",
        "        if(v == par[v]) return v;",
        "        return par[v] = find_set(par[v]);",
        "    }",
        "",
        "    void union_set(int u, int v) {",
        "        u = find_set(u);",
        "        v = find_set(v);",
        "        if(u != v) {",
        "            if(sz[u] < sz[v]) swap(u, v);",
        "            par[v] = u;",
        "            sz[u] += sz[v];",
        "        }",
        "    }",
        "",
        "    void init() {",
        "        for(int i = 1; i <= n; i++) make_set(i);",
        "    }",
        "",
        "    DSU(int _n, bool is_init = false) {",
        "        n = _n;",
        "        par.resize(n + 1);",
        "        sz.resize(n + 1);",
        "        if(is_init) init();",
        "    }    ",
        "};"
      ],
      "description": "DSU"
    },
    "Matrix operators": {
      "prefix": "math_matrix",
      "body": [
        "struct Matrix {",
        "    int n, m;",
        "    vector<vi> d;",
        "    void init(vector<vi> v) {",
        "        d = v;",
        "        n = v.size();",
        "        m = v[0].size();",
        "    }",
        " ",
        "    void I(int n) {",
        "        vector<vi> v(n, vi(n, 0));",
        "        for(int i = 0; i < n; i++) v[i][i] = 1; ",
        "        init(v);",
        "    }",
        " ",
        "    Matrix operator*(Matrix &other) {",
        "        Matrix res;",
        "        res.n = n;",
        "        res.m = other.m;",
        "        res.d.resize(n, vi(m, 0));",
        "        for(int i = 0; i < res.n; i++) {",
        "            for(int j = 0; j < res.m; j++) {",
        "                for(int k = 0; k < other.n; k++) {",
        "                    res.d[i][j] += d[i][k] * other.d[k][j];",
        "                    res.d[i][j] %= MOD;",
        "                }",
        "            }",
        "        }",
        "        return res;",
        "    }",
        " ",
        "    Matrix operator^(int k) {",
        "        assert(n == m);",
        "        Matrix res; res.I(n);",
        "        Matrix cur; cur.init(d);",
        "        while(k > 0) {",
        "            if(k & 1) res = res * cur;",
        "            cur = cur * cur;",
        "            k >>= 1; ",
        "        }",
        "        return res;",
        "    }",
        "};"
      ],
      "description": "Matrix operators"
    }
}
